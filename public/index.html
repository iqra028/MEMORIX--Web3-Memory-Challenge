<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Memorix - Web3 Memory Game</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { background: white; border-radius: 20px; padding: 30px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        h1 { text-align: center; color: #667eea; margin-bottom: 10px; font-size: 2.5em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; }
        .wallet-section { display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap; }
        .wallet-btn { padding: 12px 30px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.3s; }
        .wallet-btn:hover { background: #5568d3; transform: translateY(-2px); }
        .wallet-address { font-family: monospace; padding: 10px 20px; background: #e8f4f8; border-radius: 10px; font-size: 0.9em; }
        .main-content { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .game-panel, .side-panel { background: white; border-radius: 20px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .mode-selector { display: flex; gap: 10px; margin-bottom: 20px; }
        .mode-btn { flex: 1; padding: 15px; border: 2px solid #e0e0e0; background: white; border-radius: 10px; cursor: pointer; transition: all 0.3s; font-weight: bold; }
        .mode-btn.active { background: #667eea; color: white; border-color: #667eea; }
        .game-info { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
        .info-card { background: #f5f5f5; padding: 15px; border-radius: 10px; text-align: center; }
        .info-label { font-size: 0.8em; color: #666; margin-bottom: 5px; }
        .info-value { font-size: 1.5em; font-weight: bold; color: #667eea; }
        .timer-card { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
        .timer-card .info-label { color: rgba(255,255,255,0.9); }
        .timer-card .info-value { color: white; font-size: 2em; }
        .timer-card.warning { animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .grid { display: grid; gap: 10px; margin: 30px auto; max-width: 500px; }
        .grid.size-3 { grid-template-columns: repeat(3, 1fr); }
        .grid.size-4 { grid-template-columns: repeat(4, 1fr); }
        .grid.size-5 { grid-template-columns: repeat(5, 1fr); }
        .cell { aspect-ratio: 1; background: #e0e0e0; border-radius: 10px; cursor: pointer; transition: all 0.3s; border: 3px solid transparent; }
        .cell:hover:not(.disabled) { transform: scale(1.05); border-color: #667eea; }
        .cell.active { background: #667eea; box-shadow: 0 0 30px rgba(102, 126, 234, 0.6); transform: scale(1.1); }
        .cell.correct { background: #4caf50; animation: pulse 0.3s; }
        .cell.wrong { background: #f44336; animation: shake 0.3s; }
        .cell.disabled { cursor: not-allowed; opacity: 0.5; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } }
        .controls { display: flex; gap: 10px; }
        .btn { flex: 1; padding: 15px; font-size: 1em; border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s; font-weight: bold; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover:not(:disabled) { background: #5568d3; transform: translateY(-2px); }
        .btn-success { background: #4caf50; color: white; }
        .btn-success:hover:not(:disabled) { background: #45a049; transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { text-align: center; padding: 15px; margin: 20px 0; border-radius: 10px; font-weight: bold; }
        .status.watching { background: #fff3cd; color: #856404; }
        .status.playing { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.timeout { background: #ff9800; color: #fff; }
        .leaderboard { margin-top: 20px; }
        .leaderboard-title { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; color: #667eea; }
        .leaderboard-entry { display: flex; justify-content: space-between; padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 8px; font-size: 0.9em; }
        .leaderboard-entry.top-3 { background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); font-weight: bold; }
        .rank { font-weight: bold; color: #667eea; min-width: 30px; }
        .stats-section { margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #e0e0e0; }
        .daily-challenge-banner { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center; }
        .challenge-info { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 15px; }
        .challenge-stat { background: rgba(255,255,255,0.2); padding: 10px; border-radius: 8px; }
        .hidden { display: none !important; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-content { background: white; padding: 40px; border-radius: 20px; max-width: 500px; text-align: center; }
        .modal-title { font-size: 2em; color: #667eea; margin-bottom: 20px; }
        .modal-message { font-size: 1.1em; margin-bottom: 20px; color: #666; }
        .modal-stats { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .modal-stat-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 1.1em; }
        @media (max-width: 968px) {
            .main-content { grid-template-columns: 1fr; }
            .game-info { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MEMORIX</h1>
            <p class="subtitle">Web3 Memory Challenge - Infinite Levels & Daily Challenges</p>
            <div class="wallet-section">
                <button class="wallet-btn" id="connectBtn">Connect MetaMask</button>
                <div class="wallet-address hidden" id="walletDisplay"></div>
            </div>
        </div>

        <div class="main-content">
            <div class="game-panel">
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="infinite">Infinite Mode</button>
                    <button class="mode-btn" data-mode="daily">Daily Challenge</button>
                </div>

                <div id="dailyChallengeBanner" class="daily-challenge-banner hidden">
                    <h3>Today's Daily Challenge</h3>
                    <p>Complete perfectly within time to earn instant rewards!</p>
                    <div class="challenge-info">
                        <div class="challenge-stat">
                            <div class="info-label">Grid Size</div>
                            <div id="challengeGrid">4x4</div>
                        </div>
                        <div class="challenge-stat">
                            <div class="info-label">Steps</div>
                            <div id="challengeSteps">8</div>
                        </div>
                    </div>
                    <p style="margin-top: 15px; font-size: 0.9em;" id="challengeStatus">Loading...</p>
                </div>

                <div class="game-info">
                    <div class="info-card">
                        <div class="info-label" id="scoreLabel">Level</div>
                        <div class="info-value" id="scoreValue">1</div>
                    </div>
                    <div class="info-card">
                        <div class="info-label">Total Score</div>
                        <div class="info-value" id="totalScore">0</div>
                    </div>
                    <div class="info-card">
                        <div class="info-label">Pending Rewards</div>
                        <div class="info-value" id="pendingRewards">0 ETH</div>
                    </div>
                    <div class="info-card timer-card" id="timerCard">
                        <div class="info-label">Time Left</div>
                        <div class="info-value" id="timerValue">--</div>
                    </div>
                </div>

                <div id="status" class="status hidden"></div>

                <div id="grid" class="grid size-3"></div>

                <div class="controls">
                    <button class="btn btn-primary" id="startBtn" disabled>Connect Wallet to Play</button>
                    <button class="btn btn-success" id="withdrawBtn" disabled>Withdraw Rewards</button>
                </div>
            </div>

            <div class="side-panel">
                <div class="leaderboard">
                    <div class="leaderboard-title">Top 10 Leaderboard</div>
                    <div id="leaderboardList">
                        <p style="text-align: center; color: #999;">Loading...</p>
                    </div>
                </div>

                <div class="stats-section">
                    <h3 style="margin-bottom: 15px; color: #667eea;">Your Stats</h3>
                    <div class="stat-row">
                        <span>Total Rounds</span>
                        <strong id="statRounds">0</strong>
                    </div>
                    <div class="stat-row">
                        <span>Best Score</span>
                        <strong id="statBestScore">0</strong>
                    </div>
                    <div class="stat-row">
                        <span>Current Streak</span>
                        <strong id="statStreak">0</strong>
                    </div>
                    <div class="stat-row">
                        <span>Perfect Rounds</span>
                        <strong id="statPerfect">0</strong>
                    </div>
                    <div class="stat-row">
                        <span>Timeouts</span>
                        <strong id="statTimeouts">0</strong>
                    </div>
                    <div class="stat-row">
                        <span>Total Rewards</span>
                        <strong id="statTotalRewards">0 ETH</strong>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="resultModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-title" id="modalTitle">Round Complete!</div>
            <div class="modal-message" id="modalMessage"></div>
            <div class="modal-stats">
                <div class="modal-stat-row">
                    <span>Score:</span>
                    <strong id="modalScore">0</strong>
                </div>
                <div class="modal-stat-row">
                    <span>Correct Steps:</span>
                    <strong id="modalCorrect">0/0</strong>
                </div>
                <div class="modal-stat-row">
                    <span>Time Taken:</span>
                    <strong id="modalTime">0s</strong>
                </div>
                <div class="modal-stat-row" id="modalRewardRow">
                    <span>Reward Earned:</span>
                    <strong id="modalReward">0 ETH</strong>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-primary" id="modalContinueBtn">Continue</button>
                <button class="btn btn-primary" id="modalCloseBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:3001/api';
        const CONTRACT_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3';

        let web3Provider = null;
        let signer = null;
        let contract = null;
        let connectedAddress = null;
        let currentMode = 'infinite';
        let timerInterval = null;

        let gameState = {
            roundId: null,
            sequence: [],
            userClicks: [],
            gridSize: 3,
            isWatching: false,
            isPlaying: false,
            currentStep: 0,
            currentLevel: 1,
            timeLimit: 30000,
            roundStartTime: null,
            telemetry: { clicks: [], sequenceStartTs: null },
            showDuration: 600,
            intervalBetween: 300
        };

        const elements = {
            connectBtn: document.getElementById('connectBtn'),
            walletDisplay: document.getElementById('walletDisplay'),
            grid: document.getElementById('grid'),
            startBtn: document.getElementById('startBtn'),
            withdrawBtn: document.getElementById('withdrawBtn'),
            status: document.getElementById('status'),
            scoreValue: document.getElementById('scoreValue'),
            totalScore: document.getElementById('totalScore'),
            pendingRewards: document.getElementById('pendingRewards'),
            dailyBanner: document.getElementById('dailyChallengeBanner'),
            timerValue: document.getElementById('timerValue'),
            timerCard: document.getElementById('timerCard'),
            resultModal: document.getElementById('resultModal')
        };

        const CONTRACT_ABI = [
            "function playerStats(address) view returns (uint256 totalRounds, uint256 totalScore, uint256 totalRewards, uint256 bestScore, uint256 currentStreak, uint8 currentLevel, uint256 lastDailyChallengeDate, uint256 timeoutsCount, uint256 perfectRoundsCount)",
            "function pendingRewards(address) view returns (uint256)",
            "function withdrawReward() external",
            "event RewardWithdrawn(address indexed player, uint256 amount)"
        ];

        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                alert('MetaMask is not installed. Please install MetaMask to play.');
                return;
            }

            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                web3Provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = web3Provider.getSigner();
                connectedAddress = await signer.getAddress();
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                elements.connectBtn.classList.add('hidden');
                elements.walletDisplay.textContent = `${connectedAddress.slice(0,6)}...${connectedAddress.slice(-4)}`;
                elements.walletDisplay.classList.remove('hidden');
                elements.startBtn.disabled = false;
                elements.startBtn.textContent = 'Start Game';
                elements.withdrawBtn.disabled = false;

                await loadPlayerStats();
                await loadLeaderboard();

                if (currentMode === 'daily') {
                    await checkDailyChallengeStatus();
                }

                showStatus('Wallet connected successfully!', 'success');
                setTimeout(hideStatus, 2000);
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showStatus('Failed to connect wallet', 'error');
            }
        }

        async function loadPlayerStats() {
            if (!connectedAddress) return;

            try {
                const response = await fetch(`${API_URL}/player/${connectedAddress}/stats`);
                const data = await response.json();

                if (data.success) {
                    const stats = data.stats;
                    gameState.currentLevel = parseInt(stats.currentLevel) || 1;
                    elements.scoreValue.textContent = gameState.currentLevel;
                    elements.totalScore.textContent = stats.totalScore;
                    elements.pendingRewards.textContent = `${parseFloat(stats.pendingRewards).toFixed(4)} ETH`;

                    document.getElementById('statRounds').textContent = stats.totalRounds;
                    document.getElementById('statBestScore').textContent = stats.bestScore;
                    document.getElementById('statStreak').textContent = stats.currentStreak;
                    document.getElementById('statPerfect').textContent = stats.perfectRoundsCount || '0';
                    document.getElementById('statTimeouts').textContent = stats.timeoutsCount || '0';
                    document.getElementById('statTotalRewards').textContent = `${parseFloat(stats.totalRewards).toFixed(4)} ETH`;
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadLeaderboard() {
            try {
                const response = await fetch(`${API_URL}/leaderboard`);
                const data = await response.json();

                const list = document.getElementById('leaderboardList');

                if (data.success && data.leaderboard.length > 0) {
                    list.innerHTML = data.leaderboard.map(entry => `
                        <div class="leaderboard-entry ${entry.rank <= 3 ? 'top-3' : ''}">
                            <span class="rank">#${entry.rank}</span>
                            <span>${entry.address.substring(0, 6)}...${entry.address.substring(38)}</span>
                            <span>Lv${entry.level}</span>
                        </div>
                    `).join('');
                } else {
                    list.innerHTML = '<p style="text-align: center; color: #999;">No players yet. Be the first!</p>';
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
            }
        }

        async function checkDailyChallengeStatus() {
            if (!connectedAddress) return;

            try {
                const response = await fetch(`${API_URL}/daily-challenge/status/${connectedAddress}`);
                const data = await response.json();

                const statusEl = document.getElementById('challengeStatus');
                if (data.hasCompleted) {
                    statusEl.textContent = 'Completed today! Come back tomorrow.';
                    statusEl.style.color = '#4caf50';
                    elements.startBtn.disabled = true;
                    elements.startBtn.textContent = 'Already Completed Today';
                } else {
                    statusEl.textContent = 'Not attempted today - Play now!';
                    statusEl.style.color = 'rgba(255,255,255,0.9)';
                    elements.startBtn.disabled = false;
                    elements.startBtn.textContent = 'Start Daily Challenge';
                }
            } catch (error) {
                console.error('Error checking daily challenge:', error);
            }
        }

        function createGrid(size) {
            elements.grid.innerHTML = '';
            elements.grid.className = `grid size-${size}`;

            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.addEventListener('click', () => handleCellClick(i));
                elements.grid.appendChild(cell);
            }
        }

        function showStatus(message, type) {
            elements.status.textContent = message;
            elements.status.className = `status ${type}`;
            elements.status.classList.remove('hidden');
        }

        function hideStatus() {
            elements.status.classList.add('hidden');
        }

        function startTimer(durationMs) {
            stopTimer();
            gameState.roundStartTime = Date.now();
            gameState.timeLimit = durationMs;

            elements.timerValue.textContent = (durationMs / 1000).toFixed(1) + 's';
            elements.timerCard.classList.remove('warning');

            timerInterval = setInterval(() => {
                const elapsed = Date.now() - gameState.roundStartTime;
                const remaining = Math.max(0, durationMs - elapsed);
                const seconds = (remaining / 1000).toFixed(1);

                elements.timerValue.textContent = seconds + 's';

                if (remaining <= 5000) {
                    elements.timerCard.classList.add('warning');
                }

                if (remaining <= 0 && gameState.isPlaying) {
                    // call timeout handler
                    handleTimeout().catch(err => console.error('handleTimeout error:', err));
                }
            }, 100);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            elements.timerCard.classList.remove('warning');
            elements.timerValue.textContent = '--';
        }

        // Fixed: async handleTimeout uses gameState stored timing values
        async function handleTimeout() {
            gameState.isPlaying = false;
            stopTimer();

            const cells = elements.grid.querySelectorAll('.cell');
            cells.forEach(cell => cell.classList.add('disabled'));

            const sequence = gameState.sequence || [];
            const intervalBetween = gameState.intervalBetween || 300;
            const showDuration = gameState.showDuration || 600;
            const timeLimit = gameState.timeLimit || 30000;

            // Replay the sequence so user can see what they missed
            for (let i = 0; i < sequence.length; i++) {
                await sleep(intervalBetween);
                const idx = sequence[i];
                const cell = cells[idx];
                if (!cell) continue;
                cell.classList.add('active');
                await sleep(showDuration);
                cell.classList.remove('active');
            }

            // Return control to the player
            gameState.isWatching = false;
            gameState.isPlaying = true;
            cells.forEach(cell => cell.classList.remove('disabled'));
            showStatus('Your turn! Click the sequence...', 'playing');

            // start timer again for player-turn
            startTimer(timeLimit);
        }

        function handleCellClick(index) {
            if (!gameState.isPlaying || gameState.isWatching) return;

            const cell = elements.grid.querySelectorAll('.cell')[index];
            const clickTime = Date.now();

            gameState.telemetry.clicks.push({
                index: index,
                clientTs: clickTime,
                xPx: 0,
                yPx: 0
            });

            gameState.userClicks.push(index);
            const expectedIndex = gameState.sequence[gameState.currentStep];

            if (index === expectedIndex) {
                cell.classList.add('correct');
                setTimeout(() => cell.classList.remove('correct'), 300);
                gameState.currentStep++;

                if (gameState.currentStep === gameState.sequence.length) {
                    finishRound(false);
                }
            } else {
                cell.classList.add('wrong');
                setTimeout(() => cell.classList.remove('wrong'), 300);
                finishRound(false);
            }
        }

        async function finishRound(timeExpired = false) {
            gameState.isPlaying = false;
            stopTimer();

            const cells = elements.grid.querySelectorAll('.cell');
            cells.forEach(cell => cell.classList.add('disabled'));
            showStatus('Submitting results...', 'watching');

            try {
                const endpoint = currentMode === 'infinite' ? 'infinite' : 'daily';
                const response = await fetch(`${API_URL}/round/submit/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roundId: gameState.roundId,
                        playerAddress: connectedAddress,
                        timeExpired: timeExpired,
                        clicks: gameState.userClicks.map((index, i) => ({
                            index,
                            clientTs: gameState.telemetry.clicks[i]?.clientTs || Date.now(),
                            xPx: 0,
                            yPx: 0
                        })),
                        telemetry: gameState.telemetry
                    })
                });

                const result = await response.json();

                if (result.success) {
                    await loadPlayerStats();
                    showResultModal(result, timeExpired);
                } else {
                    if (result.error === 'ALREADY_COMPLETED') {
                        showStatus(result.message, 'error');
                        await checkDailyChallengeStatus();
                    } else {
                        throw new Error(result.error || 'Failed to submit round');
                    }
                }

            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }

            elements.startBtn.disabled = false;
        }

        function showResultModal(result, timeExpired) {
            hideStatus();

            const modal = elements.resultModal;
            const isPerfect = result.isPerfect;
            const canContinue = result.canContinue && currentMode === 'infinite';

            let title = 'Round Complete!';
            let message = '';

            if (timeExpired) {
                title = '⏱️ Time Expired!';
                message = `You ran out of time on Level ${gameState.currentLevel}. No rewards earned.`;
            } else if (isPerfect) {
                title = '🎉 Perfect!';
                if (currentMode === 'infinite') {
                    message = `Amazing! You completed Level ${gameState.currentLevel} perfectly! Level up!`;
                } else {
                    message = 'Congratulations! You completed today\'s daily challenge perfectly!';
                }
            } else {
                title = '😔 Not Quite!';
                message = `You got ${result.correctSteps} out of ${result.totalSteps} steps correct.`;
            }

            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('modalScore').textContent = result.score;
            document.getElementById('modalCorrect').textContent = `${result.correctSteps}/${result.totalSteps}`;
            document.getElementById('modalTime').textContent = (result.timeElapsedMs / 1000).toFixed(2) + 's';

            const rewardRow = document.getElementById('modalRewardRow');
            if (result.rewardEligible) {
                rewardRow.classList.remove('hidden');
                const rewardAmount = (result.correctSteps * 0.0015).toFixed(4);
                document.getElementById('modalReward').textContent = `${rewardAmount} ETH`;
            } else {
                rewardRow.classList.add('hidden');
            }

            const continueBtn = document.getElementById('modalContinueBtn');
            const closeBtn = document.getElementById('modalCloseBtn');

            if (canContinue) {
                continueBtn.classList.remove('hidden');
                continueBtn.textContent = `Continue to Level ${gameState.currentLevel}`;
                closeBtn.textContent = 'Stop Playing';
            } else {
                continueBtn.classList.add('hidden');
                if (currentMode === 'infinite') {
                    closeBtn.textContent = 'Try Again';
                } else {
                    closeBtn.textContent = 'Close';
                }
            }

            modal.classList.remove('hidden');
        }

        async function withdrawRewards() {
            if (!contract || !connectedAddress) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                showStatus('Initiating withdrawal...', 'watching');
                elements.withdrawBtn.disabled = true;

                const tx = await contract.withdrawReward();
                showStatus('Transaction submitted. Waiting for confirmation...', 'watching');

                await tx.wait();

                showStatus('Withdrawal successful! Check your wallet.', 'success');
                await loadPlayerStats();

                setTimeout(() => {
                    hideStatus();
                    elements.withdrawBtn.disabled = false;
                }, 3000);

            } catch (error) {
                console.error('Withdrawal error:', error);

                let errorMessage = 'Withdrawal failed';
                if (error.message && error.message.includes('No rewards')) {
                    errorMessage = 'No rewards to withdraw';
                } else if (error.message && (error.message.includes('user rejected') || error.message.includes('rejected by user'))) {
                    errorMessage = 'Transaction cancelled';
                }

                showStatus(errorMessage, 'error');
                elements.withdrawBtn.disabled = false;

                setTimeout(hideStatus, 3000);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        elements.connectBtn.addEventListener('click', connectWallet);
        elements.startBtn.addEventListener('click', startGame);
        elements.withdrawBtn.addEventListener('click', withdrawRewards);

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;

                if (currentMode === 'daily') {
                    elements.dailyBanner.classList.remove('hidden');
                    document.getElementById('scoreLabel').textContent = 'Challenge';
                    if (connectedAddress) {
                        checkDailyChallengeStatus();
                    }
                } else {
                    elements.dailyBanner.classList.add('hidden');
                    document.getElementById('scoreLabel').textContent = 'Level';
                    if (connectedAddress) {
                        elements.startBtn.disabled = false;
                        elements.startBtn.textContent = 'Start Game';
                    }
                }
            });
        });

        document.getElementById('modalContinueBtn').addEventListener('click', () => {
            elements.resultModal.classList.add('hidden');
            startGame();
        });

        document.getElementById('modalCloseBtn').addEventListener('click', () => {
            elements.resultModal.classList.add('hidden');
            if (currentMode === 'daily') {
                checkDailyChallengeStatus();
            }
        });

        // Safer event listener for accounts changes
        if (window.ethereum && window.ethereum.on) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    location.reload();
                } else if (accounts[0] !== connectedAddress) {
                    location.reload();
                }
            });
        }

        // Initial setup helpers and game flow

        // Fully implemented playSequence: animates and hands control to player
        async function playSequence(sequence, showDuration = 600, intervalBetween = 300, timeLimit = 30000) {
            gameState.showDuration = showDuration;
            gameState.intervalBetween = intervalBetween;
            gameState.timeLimit = timeLimit;
            gameState.sequence = sequence;
            gameState.userClicks = [];
            gameState.currentStep = 0;
            gameState.isWatching = true;
            gameState.isPlaying = false;

            showStatus(`Watch carefully! ${sequence.length} steps...`, 'watching');

            const cells = elements.grid.querySelectorAll('.cell');
            // disable user interaction while sequence is playing
            cells.forEach(cell => cell.classList.add('disabled'));

            // small delay before starting
            await sleep(400);

            for (let i = 0; i < sequence.length; i++) {
                const idx = sequence[i];
                const cell = cells[idx];
                if (!cell) continue;

                // highlight
                cell.classList.add('active');
                await sleep(showDuration);
                cell.classList.remove('active');

                // wait between elements (but not after last)
                if (i < sequence.length - 1) await sleep(intervalBetween);
            }

            // sequence finished — enable user interaction
            gameState.isWatching = false;
            gameState.isPlaying = true;
            cells.forEach(cell => cell.classList.remove('disabled'));
            showStatus('Your turn! Click the sequence...', 'playing');

            // start the timer for player's response
            startTimer(timeLimit);
        }

        async function startGame() {
            if (!connectedAddress) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            showStatus('Starting new round...', 'watching');
            elements.startBtn.disabled = true;

            try {
                const endpoint = currentMode === 'infinite' ? 'infinite' : 'daily';
                const response = await fetch(`${API_URL}/round/start/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerAddress: connectedAddress,
                        level: gameState.currentLevel
                    })
                });

                const data = await response.json();

                if (!data.success) {
                    if (data.error === 'ALREADY_COMPLETED') {
                        showStatus(data.message, 'error');
                        await checkDailyChallengeStatus();
                        return;
                    }
                    throw new Error(data.error || 'Failed to start round');
                }

                gameState.roundId = data.roundId;
                // server sequence and grid/timing
                gameState.sequence = data.sequence || [];
                gameState.gridSize = data.gridSize || 3;
                gameState.timeLimit = data.timeLimit || 30000;
                gameState.userClicks = [];
                gameState.currentStep = 0;
                gameState.telemetry.clicks = [];
                gameState.telemetry.sequenceStartTs = Date.now();

                createGrid(data.gridSize || 3);
                await playSequence(data.sequence || [], data.showDuration || 600, data.intervalBetween || 300, data.timeLimit || 30000);

            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                elements.startBtn.disabled = false;
                stopTimer();
            }
        }

        // initial UI
        createGrid(3);
        loadLeaderboard();
        setInterval(loadLeaderboard, 30000);
    </script>
</body>
</html>
